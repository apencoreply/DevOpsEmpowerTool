parameters:
  - name: tokens
    type: string
    default: '4000'
  - name: temperature
    type: string
    default: '0.7'
  - name: model
    type: string
    default: 'GPT4'
  - name: workingDir
    type: string
    default: '$(System.DefaultWorkingDirectory)'
  - name: caption
    type: string
    default: 'Checkout our suggestions!'
  - name: chatid
    type: string
    default: '549538016'
  - name: azSubscription
    type: string
    default: ''
    

jobs:
- job: OpenAi
  displayName: OpenAi
  pool:
    vmImage: 'windows-2019'
  
  steps:
  - task: DownloadPipelineArtifact@2
    displayName: 'Download JTL Results Artifact'
    inputs:
      artifactName: 'JTLResults'
      targetPath: '$(System.DefaultWorkingDirectory)'

  # - task: PowerShell@2
  #   displayName: 'Prepare JTL Results and Function Code'
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       $workingDir = "${{ parameters.workingDir }}"
  #       echo "Function Code:"
  #       cat "$workingDir/*.cs"
  #       echo "JTL Results:"
  #       cat "$(System.DefaultWorkingDirectory)/TestResults.txt"

  - task: AzureKeyVault@2
    inputs:
      azureSubscription: '${{ parameters.azSubscription }}'
      KeyVaultName: 'DevEmpower'
      SecretsFilter: '${{ parameters.model }}-KEY,${{ parameters.model }}-URL'
      RunAsPreJob: false

  - task: PowerShell@2
    displayName: 'Call ChatGPT API'
    inputs:
      targetType: 'inline'
      script: |
        $jtlResultsFile = "$(System.DefaultWorkingDirectory)/TestResults.txt"  
        $functionCodeFile = "${{ parameters.workingDir }}/*.cs"  
        $apiKey = "$(${{ parameters.model }}-KEY)"
        $apiUrl = "$(${{ parameters.model }}-URL)"

        # Read JTL results
        $jtlResults = Get-Content -Path $jtlResultsFile

        # Read function code
        $functionCode = Get-Content -Path $functionCodeFile

        # Prepare payload for API request
        #"Provide me example on how could improve the snippet of code, based on Function code and JTL Results:",  
        #"Provide improved implementation example taking into account the following:",
        #'You are a system that analyzes source code and JMeter results to assist any type of developer in enhancing and improving performance in the code.'
        $payload = @{
          messages = @(
            @{role = "system";content= "You are a system that analyzes source code and JMeter results to assist any type of developer in enhancing and improving performance in the code."},
            @{role = "user";content= "Provide improved implementation example taking into account the following:\n----\nJTL Results:\n---\nResult from the JTL file from the JMeter test in which are saved the errors and the description: --- timeStamp,elapsed,label,responseCode,responseMessage,threadName,dataType,success,failureMessage,bytes,sentBytes,grpThreads,allThreads,URL,Latency,IdleTime,Connect 1693232919987,8580,HTTP Request,404,Not Found,Thread Group 1-1,,false,,82,152,10,10,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=240,8578,0,4539 1693232919987,8580,HTTP Request,404,Not Found,Thread Group 1-2,,false,,82,152,10,10,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=579,8578,0,4533 1693232920587,7981,HTTP Request,404,Not Found,Thread Group 1-10,,false,,82,152,10,10,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=397,7979,0,3943 1693232919988,8580,HTTP Request,404,Not Found,Thread Group 1-3,,false,,82,152,10,10,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=651,8576,0,4536 1693232920088,8480,HTTP Request,404,Not Found,Thread Group 1-5,,false,,82,152,10,10,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=201,8476,0,4441 1693232919988,8580,HTTP Request,404,Not Found,Thread Group 1-6,,false,,150,152,4,4,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=180,161,0,0 1693232934285,163,HTTP Request,404,Not Found,Thread Group 1-10,,false,,150,152,3,3,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=900,163,0,0 1693232934308,166,HTTP Request,404,Not Found,Thread Group 1-8,,false,,150,152,2,2,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=725,166,0,0 1693232934326,164,HTTP Request,404,Not Found,Thread Group 1-3,,false,,150,152,1,1,https://getwebapi.azurewebsites.net/api/GetWebAPI?id=963,164,0,0  --- Summary results: --- summary =    100 in 00:00:16 =    6.4/s Avg:  1340 Min:   161 Max:  8580 Err:    88 (88.00%)  ---\n---\nFunction Code:\n---\nusing System; using System.IO; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Microsoft.Azure.WebJobs; using Microsoft.Azure.WebJobs.Extensions.Http; using Microsoft.AspNetCore.Http; using Microsoft.Extensions.Logging; using Newtonsoft.Json; using System.Net.Http; using Microsoft.Azure.Cosmos; using System.ComponentModel; using Azure; using System.Collections.Generic; using System.Collections.Concurrent;  namespace GetWebAPI {     public static class GetWebAPI     {         private static readonly string cosmosDbEndpoint = Environment.GetEnvironmentVariable(\"DBENDPOINT\", EnvironmentVariableTarget.Process);         private static readonly string cosmosDbKey = Environment.GetEnvironmentVariable(\"DBKEY\", EnvironmentVariableTarget.Process);         private static readonly string databaseId = Environment.GetEnvironmentVariable(\"DBID\", EnvironmentVariableTarget.Process);         private static readonly string containerId = Environment.GetEnvironmentVariable(\"CONTAINERID\", EnvironmentVariableTarget.Process);         private static readonly CosmosClient cosmosClient = new CosmosClient(cosmosDbEndpoint, cosmosDbKey);         private static readonly Microsoft.Azure.Cosmos.Container cosmosContainer = cosmosClient.GetContainer(databaseId, containerId);          [FunctionName(\"GetWebAPI\")]         public static async Task<IActionResult> Run(             [HttpTrigger(AuthorizationLevel.Anonymous, \"get\", Route = null)] HttpRequest req,             ILogger log)         {             try             {                 string id = req.Query[\"id\"];                  // Validate that the ID is provided                 if (string.IsNullOrEmpty(id))                 {                     return new BadRequestObjectResult(\"The 'id' query parameter is required.\");                 }                  // Retrieve the item from Cosmos DB                 var response = await cosmosContainer.ReadItemAsync<RequestDocument>(id, new PartitionKey(id));                  return new OkObjectResult(response.Resource);             }             catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)             {                 return new NotFoundResult();             }             catch (Exception ex)             {                 log.LogError(ex, \"An error occurred while retrieving data from Cosmos DB.\");                 return new StatusCodeResult(StatusCodes.Status500InternalServerError);             }         }     }      public class RequestDocument     {         public string id { get; set; }         public string categoryId { get; set; }         public string categoryName { get; set; }         public string sku { get; set; }         public string name { get; set; }         public string description { get; set; }         public double Price { get; set; }         public List<Tag> tags { get; set; }     }      public class Tag     {         public string id { get; set; }         public string name { get; set; }     } }\n---\n----"},
            @{role = "assistant";content= "The current implementation is mostly correct, but it could be improved to avoid creating a new CosmosClient and container for each function invocation. Doing so would enhance your application's performance. \n\nThe static `CosmosClient` and `Container` objects should be initialized lazily to ensure that they're only created when the function is executed, not when the function app starts. This approach also allows for connection reuse, which can improve performance by reducing the time it takes to establish a connection to the Cosmos DB.\n\nHere's the improved implementation:\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Azure.WebJobs;\nusing Microsoft.Azure.WebJobs.Extensions.Http;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\nusing System.Net.Http;\nusing Microsoft.Azure.Cosmos;\nusing System.ComponentModel;\nusing Azure;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\n\nnamespace GetWebAPI\n{\n    public static class GetWebAPI\n    {\n        private static readonly Lazy<CosmosClient> lazyClient = new Lazy<CosmosClient>(InitializeCosmosClient);\n        private static readonly Lazy<Microsoft.Azure.Cosmos.Container> lazyContainer = new Lazy<Microsoft.Azure.Cosmos.Container>(() => InitializeCosmosContainer(lazyClient.Value));\n\n        [FunctionName(\"GetWebAPI\")]\n        public static async Task<IActionResult> Run(\n            [HttpTrigger(AuthorizationLevel.Anonymous, \"get\", Route = null)] HttpRequest req,\n            ILogger log)\n        {\n            try\n            {\n                string id = req.Query[\"id\"];\n\n                // Validate that the ID is provided\n                if (string.IsNullOrEmpty(id))\n                {\n                    return new BadRequestObjectResult(\"The 'id' query parameter is required.\");\n                }\n\n                // Retrieve the item from Cosmos DB\n                var response = await lazyContainer.Value.ReadItemAsync<RequestDocument>(id, new PartitionKey(id));\n\n                return new OkObjectResult(response.Resource);\n            }\n            catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                return new NotFoundResult();\n            }\n            catch (Exception ex)\n            {\n                log.LogError(ex, \"An error occurred while retrieving data from Cosmos DB.\");\n                return new StatusCodeResult(StatusCodes.Status500InternalServerError);\n            }\n        }\n\n        private static CosmosClient InitializeCosmosClient()\n        {\n            string cosmosDbEndpoint = Environment.GetEnvironmentVariable(\"DBENDPOINT\", EnvironmentVariableTarget.Process);\n            string cosmosDbKey = Environment.GetEnvironmentVariable(\"DBKEY\", EnvironmentVariableTarget.Process);\n            return new CosmosClient(cosmosDbEndpoint, cosmosDbKey);\n        }\n\n        private static Microsoft.Azure.Cosmos.Container InitializeCosmosContainer(CosmosClient client)\n        {\n            string databaseId = Environment.GetEnvironmentVariable(\"DBID\", EnvironmentVariableTarget.Process);\n            string containerId = Environment.GetEnvironmentVariable(\"CONTAINERID\", EnvironmentVariableTarget.Process);\n            return client.GetContainer(databaseId, containerId);\n        }\n    }\n\n    public class RequestDocument\n    {\n        public string id { get; set; }\n        public string categoryId { get; set; }\n        public string categoryName { get; set; }\n        public string sku { get; set; }\n        public string name { get; set; }\n        public string description { get; set; }\n        public double Price { get; set; }\n        public List<Tag> tags { get; set; }\n    }\n\n    public class Tag\n    {\n        public string id { get; set; }\n        public string name { get; set; }\n    }\n}\n```\n\nThis code will create the `CosmosClient` and `Container` objects only once, when they are accessed for the first time, and reuse them for subsequent function invocations. This approach reduces the overhead of creating these objects for every function invocation and improves the performance of your function."},
            @{role = "user";content= "Provide improved implementation example taking into account the following:\n----\nJTL Results:\n---\nResult from the JTL file from the JMeter test in which are saved the errors and the description: --- timeStamp,elapsed,label,responseCode,responseMessage,threadName,dataType,success,failureMessage,bytes,sentBytes,grpThreads,allThreads,URL,Latency,IdleTime,Connect 1693232845131,225,HTTP Request,500,Internal Server Error,Thread Group 1-2,,false,,162,722,10,10,https://fidelapp.azurewebsites.net/api/FiDelApp,225,0,0 1693232845851,160,HTTP Request,500,Internal Server Error,Thread Group 1-2,,false,,162,722,10,10,https://fidelapp.azurewebsites.net/api/FiDelApp,160,0,0 1693232846280,159,HTTP Request,500,Internal Server Error,Thread Group 1-7,,false,,162,722,6,6,https://fidelapp.azurewebsites.net/api/FiDelApp,159,0,0 1693232849108,223,HTTP Request,500,Internal Server Error,Thread Group 1-4,,false,,162,722,3,3,https://fidelapp.azurewebsites.net/api/FiDelApp,223,0,0 1693232849651,159,HTTP Request,500,Internal Server Error,Thread Group 1-4,,false,,162,722,3,3,https://fidelapp.azurewebsites.net/api/FiDelApp,159,0,0 1693232850366,228,HTTP Request,500,Internal Server Error,Thread Group 1-8,,false,,162,722,1,1,https://fidelapp.azurewebsites.net/api/FiDelApp,228,0,0 1693232850766,165,HTTP Request,500,Internal Server Error,Thread Group 1-8,,false,,162,722,1,1,https://fidelapp.azurewebsites.net/api/FiDelApp,165,0,0  --- Summary results: --- summary +     90 in 00:00:07 =   12.3/s Avg:   440 Min:   159 Max:  4814 Err:     5 (5.56%) Active: 3 Started: 10 Finished: 7 summary +     10 in 00:00:01 =    9.4/s Avg:   172 Min:   161 Max:   228 Err:     2 (20.00%) Active: 0 Started: 10 Finished: 10 summary =    100 in 00:00:08 =   11.9/s Avg:   413 Min:   159 Max:  4814 Err:     7 (7.00%)  ---\n---\nFunction Code:\n---\nusing System; using System.IO; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Microsoft.Azure.WebJobs; using Microsoft.Azure.WebJobs.Extensions.Http; using Microsoft.AspNetCore.Http; using Microsoft.Extensions.Logging; using Newtonsoft.Json; using System.Net.Http; using Microsoft.Azure.Cosmos; using System.ComponentModel; using Azure; using System.Collections.Generic;  namespace FiDelApp {       public static class FiDelApp     {         private static readonly HttpClient httpClient = new HttpClient();         private static readonly string cosmosDbEndpoint = Environment.GetEnvironmentVariable(\"DBENDPOINT\", EnvironmentVariableTarget.Process);         private static readonly string cosmosDbKey = Environment.GetEnvironmentVariable(\"DBKEY\", EnvironmentVariableTarget.Process);         private static readonly string databaseId = Environment.GetEnvironmentVariable(\"DBID\", EnvironmentVariableTarget.Process);         private static readonly string containerId = Environment.GetEnvironmentVariable(\"CONTAINERID\", EnvironmentVariableTarget.Process);         private static readonly CosmosClient cosmosClient = new CosmosClient(cosmosDbEndpoint, cosmosDbKey);         private static readonly Microsoft.Azure.Cosmos.Container cosmosContainer = cosmosClient.GetContainer(databaseId, containerId);          [FunctionName(\"FiDelApp\")]         public static async Task<IActionResult> Run(             [HttpTrigger(AuthorizationLevel.Anonymous, \"post\", Route = null)] HttpRequest req,             ILogger log)         {             try             {                 string requestBody = await new StreamReader(req.Body).ReadToEndAsync();                  // Deserialize the JSON request body                 var requestDocument = JsonConvert.DeserializeObject<RequestDocument>(requestBody);                  // Validate that the ID is provided                 if (string.IsNullOrEmpty(requestDocument.id))                 {                     return new BadRequestObjectResult(\"The 'id' property is required.\");                 }                  // Insert the JSON document into Cosmos DB                 var response = await cosmosContainer.CreateItemAsync(requestDocument);                  return new OkObjectResult(\"Data inserted successfully! Well Done! (12/07/2023)\");             }             catch (Exception ex)             {                 log.LogError(ex, \"An error occurred while inserting data into Cosmos DB.\");                 return new StatusCodeResult(StatusCodes.Status500InternalServerError);             }         }     }     public class RequestDocument     {         public string id { get; set; }         public string categoryId { get; set; }         public string categoryName { get; set; }         public string sku { get; set; }         public string name { get; set; }         public string description { get; set; }         public double Price { get; set; }         public List<Tag> tags { get; set; }     }     public class Tag     {         public string id { get; set; }         public string name { get; set; }     } }\n---\n----"},
            @{role = "assistant";content= "One of the improvements that can be made to the function code is the addition of error handling for deserialization. If the incoming JSON payload is not in the expected format, the function will throw an exception which can result in a 500 Internal Server Error response. By adding error handling for this case, a 400 Bad Request response can be returned, which is more accurate. \n\nHere is the improved implementation:\n\n```csharp\nusing System; \nusing System.IO; \nusing System.Threading.Tasks; \nusing Microsoft.AspNetCore.Mvc; \nusing Microsoft.Azure.WebJobs; \nusing Microsoft.Azure.WebJobs.Extensions.Http; \nusing Microsoft.AspNetCore.Http; \nusing Microsoft.Extensions.Logging; \nusing Newtonsoft.Json; \nusing System.Net.Http; \nusing Microsoft.Azure.Cosmos; \nusing System.ComponentModel; \nusing Azure; \nusing System.Collections.Generic;\n\nnamespace FiDelApp \n{ \n    public static class FiDelApp \n    { \n        private static readonly HttpClient httpClient = new HttpClient(); \n        private static readonly string cosmosDbEndpoint = Environment.GetEnvironmentVariable(\"DBENDPOINT\", EnvironmentVariableTarget.Process); \n        private static readonly string cosmosDbKey = Environment.GetEnvironmentVariable(\"DBKEY\", EnvironmentVariableTarget.Process); \n        private static readonly string databaseId = Environment.GetEnvironmentVariable(\"DBID\", EnvironmentVariableTarget.Process); \n        private static readonly string containerId = Environment.GetEnvironmentVariable(\"CONTAINERID\", EnvironmentVariableTarget.Process); \n        private static readonly CosmosClient cosmosClient = new CosmosClient(cosmosDbEndpoint, cosmosDbKey); \n        private static readonly Microsoft.Azure.Cosmos.Container cosmosContainer = cosmosClient.GetContainer(databaseId, containerId);\n\n        [FunctionName(\"FiDelApp\")] \n        public static async Task<IActionResult> Run( \n            [HttpTrigger(AuthorizationLevel.Anonymous, \"post\", Route = null)] HttpRequest req, \n            ILogger log) \n        { \n            try \n            { \n                string requestBody = await new StreamReader(req.Body).ReadToEndAsync(); \n\n                // Try to deserialize the JSON request body \n                RequestDocument requestDocument;\n                try\n                {\n                    requestDocument = JsonConvert.DeserializeObject<RequestDocument>(requestBody);\n                }\n                catch (JsonException)\n                {\n                    return new BadRequestObjectResult(\"Could not deserialize the JSON payload. Please check the payload format.\");\n                }\n\n                // Validate that the ID is provided \n                if (string.IsNullOrEmpty(requestDocument.id)) \n                { \n                    return new BadRequestObjectResult(\"The 'id' property is required.\"); \n                } \n\n                // Insert the JSON document into Cosmos DB \n                var response = await cosmosContainer.CreateItemAsync(requestDocument); \n\n                return new OkObjectResult(\"Data inserted successfully! Well Done! (12/07/2023)\"); \n            } \n            catch (Exception ex) \n            { \n                log.LogError(ex, \"An error occurred while inserting data into Cosmos DB.\"); \n                return new StatusCodeResult(StatusCodes.Status500InternalServerError); \n            } \n        } \n    }\n\n    public class RequestDocument \n    { \n        public string id { get; set; } \n        public string categoryId { get; set; } \n        public string categoryName { get; set; } \n        public string sku { get; set; } \n        public string name { get; set; } \n        public string description { get; set; } \n        public double Price { get; set; } \n        public List<Tag> tags { get; set; } \n    } \n\n    public class Tag \n    { \n        public string id { get; set; } \n        public string name { get; set; } \n    } \n}\n```\n\nThis way, if the incoming JSON payload is not in the expected format, a 400 Bad Request response will be returned, providing the client with more accurate information about the error."},
            @{ role = 'user'; content = (
              "----",  
              "JTL Results:",  
              "---",  
              "$jtlResults",
              "---",  
              "Function Code:",  
              "---",  
              "$functionCode",
              "---",  
              "----"  
            ) -join "`n"
            }
          )
          temperature = $temperature
          max_tokens = $tokens
        }
        $payloadJson = $payload | ConvertTo-Json

        # Make API request
        $headers = @{
            "Content-Type" = "application/json"
            "api-key" = $apiKey
        }
        $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers -Method Post -Body $payloadJson
        # Process the API response as needed
        # For example, extract and utilize the generated text
        $generatedText = $response.choices[0].message.content
        #$generatedText = $response

        # Display the generated text
        Write-Host $generatedText

        $generatedText | Out-File "$(System.DefaultWorkingDirectory)/generatedText.md" -Encoding utf8

        # Save the user content to a file  
        $payload.messages[1].content | Out-File "$(System.DefaultWorkingDirectory)/userContent.txt" -Encoding utf8
    

  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.x'
      addToPath: true
      architecture: 'x64'

  - script: |
      python -m pip install --upgrade pip
      pip install requests
    displayName: 'Install requests'
  - task: PythonScript@0
    inputs:
      scriptSource: 'inline'
      script: |
        import requests
        
        bot_token = '6096186625:AAHcTptWfiK5CIAmSEcmjEtpfJA1oiKGR_Q'
        chat_id = '${{ parameters.chatid }}'
        document_paths = [r'$(System.DefaultWorkingDirectory)/generatedText.md',
                         r'$(System.DefaultWorkingDirectory)/userContent.txt']
        caption = '${{ parameters.caption }}'
        
        api_url = f'https://api.telegram.org/bot{bot_token}/sendDocument'
        
        for document_path in document_paths:
          with open(document_path, 'rb') as document:
              files = {'document': document}
              payload = {
                  'chat_id': chat_id,
                  'caption': caption
              }
              response = requests.post(api_url, files=files, data=payload)
        
        # Check the response status code or content for errors
        print(response.status_code, response.content)
